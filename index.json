[{"categories":["Notas"],"contents":"Después de usar VIM, usar hjkl como direcciones es muy cómodo La wiki de Arch explica cómo hacer que todos los teclados hagan que BloqMayús+hjkl se reconozca como las flechas de dirección en cualquier sesión de X11, pero es una explicación algo escueta y no quiero leer todo lo anterior y más para llegar a eso.\nEsta guía la escribo sin entender los conceptos tan abstractos que usa X11 para enviar eventos de teclado (scancodes, keycodes, layers, modifiers, symbols \u0026hellip;)\nPrimero que nada, conviene quitar cualquier modificación previa a BloqMayús. Esto incluye keybinds puestos en awesome, y opciones como option caps:none de setxkbmap.\nSi algún atajo de awesome intercepta la tecla BloqMayús, entonces xev mostrará eventos de BloqMayús como líneas llenas de ceros. Algo similar a esto: KeymapNotify event, serial 36, synthetic NO, window 0x0, keys: 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Y si hemos configurado setxkbmap para cambiar el comportamiento de BloqMayús, tenemos que ir a /etc/X11/xorg.conf.d/00-keyboard.conf y quitar lo que esté en la línea que dice Option \u0026quot;XkbOptions\u0026quot;. Por ejemplo, en vez de: Section \u0026#34;InputClass\u0026#34; Identifier \u0026#34;system-keyboard\u0026#34; MatchIsKeyboard \u0026#34;on\u0026#34; Option \u0026#34;XkbLayout\u0026#34; \u0026#34;latam\u0026#34; Option \u0026#34;XkbOptions\u0026#34; \u0026#34;keypad:pointerkeys,caps:none\u0026#34; EndSection Queremos:\nSection \u0026#34;InputClass\u0026#34; Identifier \u0026#34;system-keyboard\u0026#34; MatchIsKeyboard \u0026#34;on\u0026#34; Option \u0026#34;XkbLayout\u0026#34; \u0026#34;latam\u0026#34; Option \u0026#34;XkbOptions\u0026#34; \u0026#34;keypad:pointerkeys\u0026#34; EndSection Pongo todo el archivo en vez de sólo la línea importante para recordar cómo se ve XkbOptions en un archivo de configuración. Las opciones van separadas por comas sin espacios, y tienen la forma objeto:propiedad.\nYa que quitamos a xkbmap y awesome de enmedio, podemos cambiar archivos más profundos. Primero que nada, hagamos a /usr/share/X11/xkb nuestro directorio de trabajo:\ncd /usr/share/X11/xkb Archivo types Abrimos types/complete con un editor de texto. Originalmente se veía así:\ndefault xkb_types \u0026#34;complete\u0026#34; { include \u0026#34;basic\u0026#34; include \u0026#34;mousekeys\u0026#34; include \u0026#34;pc\u0026#34; include \u0026#34;iso9995\u0026#34; include \u0026#34;level5\u0026#34; include \u0026#34;extra\u0026#34; include \u0026#34;numpad\u0026#34; }; Ahora se ve así:\ndefault xkb_types \u0026#34;complete\u0026#34; { include \u0026#34;basic\u0026#34; include \u0026#34;mousekeys\u0026#34; include \u0026#34;pc\u0026#34; include \u0026#34;iso9995\u0026#34; include \u0026#34;level5\u0026#34; include \u0026#34;extra\u0026#34; include \u0026#34;numpad\u0026#34; type \u0026#34;CUST_CAPSLOCK\u0026#34; { modifiers= Shift+Lock; map[Shift] = Level2; //maps shift and no Lock. Shift+Alt goes here, too, because Alt isn\u0026#39;t in modifiers. map[Lock] = Level3; map[Shift+Lock] = Level3; //maps shift and Lock. Shift+Lock+Alt goes here, too. level_name[Level1]= \u0026#34;Base\u0026#34;; level_name[Level2]= \u0026#34;Shift\u0026#34;; level_name[Level3]= \u0026#34;Lock\u0026#34;; }; }; Podemos poner comentarios empezando con //, y en este archivo estamos usando 4 espacios para indentar, aunque dudo que importe. Incluso líneas en blanco deberían dejar todo bien siempre y cuando los delimitadores (; {}; []) estén bien.\nArchivo compatibility Abrimos compat/complete con un editor de texto. Originalmente se veía así:\ndefault xkb_compatibility \u0026#34;complete\u0026#34; { include \u0026#34;basic\u0026#34; augment \u0026#34;iso9995\u0026#34; augment \u0026#34;mousekeys\u0026#34; augment \u0026#34;accessx(full)\u0026#34; augment \u0026#34;misc\u0026#34; augment \u0026#34;xfree86\u0026#34; augment \u0026#34;level5\u0026#34; augment \u0026#34;caps(caps_lock)\u0026#34; }; Ahora se ve así:\ndefault xkb_compatibility \u0026#34;complete\u0026#34; { include \u0026#34;basic\u0026#34; augment \u0026#34;iso9995\u0026#34; augment \u0026#34;mousekeys\u0026#34; augment \u0026#34;accessx(full)\u0026#34; augment \u0026#34;misc\u0026#34; augment \u0026#34;xfree86\u0026#34; augment \u0026#34;level5\u0026#34; augment \u0026#34;caps(caps_lock)\u0026#34; interpret Caps_Lock+AnyOfOrNone(all) { action= SetMods(modifiers=Lock); }; }; Archivo symbols Esta parte es la más complicada. Aunque podríamos pensar que debemos modificar symbols/latam, en realidad debemos cambiar symbols/pc. De todas formas symbols/latam tiene mapeos que se aplicarán después de incluir symbols/pc. Resulta que pc aplica a todas las distribuciones de teclado. Entonces, abrimos symbols/pc con un editor de texto.\nVamos a escribir varias entradas en el bloque xkb_symbols \u0026quot;pc105\u0026quot;.\nAquí pondré las primeras 10 líneas de ese archivo, y la última después de los puntos suspensivos:\n// The keys that are common to all standard layouts. default partial alphanumeric_keys modifier_keys xkb_symbols \u0026#34;pc105\u0026#34; { key \u0026lt;ESC\u0026gt; {[ Escape ]}; key \u0026lt;TAB\u0026gt; {[ Tab, ISO_Left_Tab ]}; key \u0026lt;CAPS\u0026gt; {[ Caps_Lock ]}; key \u0026lt;BKSP\u0026gt; {[ BackSpace, BackSpace ]}; key \u0026lt;BKSL\u0026gt; {[ backslash, bar ]}; ... // \u0026lt;-----Esos puntos suspensivos no son parte del archivo (-: }; Las entradas que vamos a poner pueden ir donde sea. Yo las puse entre la que dice \u0026lt;CAPS\u0026gt; y la que dice \u0026lt;BKSP\u0026gt;. Necesitamos una para cada dirección (arriba, abajo, izquierda, derecha).\nLa forma de las entradas es:\nkey \u0026lt;$1\u0026gt; { | type= \u0026#34;CUST_CAPSLOCK\u0026#34;, | symbols[Group1]= [ $2, $3, $4], | actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;$5\u0026gt;, clearmods=Lock) ] }; Donde dejé marcados los espacios que hay que llenar con $número. Ahora pongo una guía de cómo encontrar cada uno de esos espacios:\nPrimer elemento $1 es el código que se encuentra en el archivo keycodes/xfree86. En ese archivo encontraremos líneas como:\n\u0026lt;CAPS\u0026gt; = 66; \u0026lt;AC01\u0026gt; = 38; \u0026lt;AC02\u0026gt; = 39; \u0026lt;AC03\u0026gt; = 40; Lo que haremos será ejecutar xev y presionar la tecla que queremos reasignar. Por ejemplo, queremos que la h sea la flecha a la izquierda. Si presionamos la h cuando la ventana de xev está enfocada, la terminal muestra esto sobre el evento KeyRelease:\nKeyRelease event, serial 36, synthetic NO, window 0x4400001, root 0x1e1, subw 0x0, time 162032730, (889,773), root:(891,793), state 0x10, keycode 43 (keysym 0x68, h), same_screen YES, XLookupString gives 1 bytes: (68) \u0026#34;h\u0026#34; XFilterEvent returns: False Lo importante aquí es la línea con keycode 43. De hecho, si lo anterior es confuso, podíamos haber corrido xev detrás de un pipe hacia grep así:\nxev | grep keycode para tener una salida más legible (TODO: awk debería ser aún más limpio. O se necesitan 2 pipes?).\nComo sea, ahora buscaremos la línea que asigna un label al keycode 43 en keycodes/xfree86:\n... \u0026lt;AC06\u0026gt; = 43; ... Entonces lo que debe ir en la marca $1 es AC06 para el mapeo de la h.\nSegundo, tercero y cuarto elemento No me he dedicado a leer sobre el verdadero significado de cada entrada. Creo que está explicado en la wiki de arch, pero de todas formas, para estos mapeos sólo puse la tecla minúscula, mayúscula, y su nombre en inglés (no es ni un label ni un keycode. No sé qué sea.).\nAsí, por ejemplo, para remapear la h, las entradas $2, $3 y $4 dicen:\nh H Left Sin comillas ni nada. Al final de esta guía pongo las entradas completas para los 4 remapeos.\nQuinto elemento Aquí pondemos el label de la tecla que nos gustaría que X11 envíe cuando presionamos BloqMayús + hjkl.\nPor alguna razón (más bien porque no leí la wiki) xev indica que los keycodes de las flechas están mapeados a teclas que en keycodes/xfree86 tienen etiquetas inesperadas como \u0026lt;RALT\u0026gt;.\nPero lo correcto es poner etiquetas \u0026lt;UP\u0026gt; \u0026lt;DOWN\u0026gt; \u0026lt;LEFT\u0026gt; y \u0026lt;RGHT\u0026gt; (no me comí la I en RGHT). Esas etiquetas aparecen así en mi keycodes/xfree86:\n\u0026lt;UP\u0026gt; = 98; \u0026lt;LEFT\u0026gt; = 100; \u0026lt;DOWN\u0026gt; = 104; \u0026lt;RGHT\u0026gt; = 102; Y no tengo idea de qué teclas físicas envían esos códigos. Pero para el quinto elemento sólo nos interesan las etiquetas, las cuales tengo entendido que son de por sí arbitrarias (como aliases).\nEntonces, para el remapeo de la h, el quinto elemento es LEFT.\nLas entradas que yo hice Mis entradas quedaron así:\nkey \u0026lt;AC06\u0026gt; { | type= \u0026#34;CUST_CAPSLOCK\u0026#34;, | symbols[Group1]= [ h, H, Left], | actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;LEFT\u0026gt;, clearmods=Lock) ] }; key \u0026lt;AC09\u0026gt; { | type= \u0026#34;CUST_CAPSLOCK\u0026#34;, | symbols[Group1]= [ l, L, Right], | actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;RGHT\u0026gt;, clearmods=Lock) ] }; key \u0026lt;AC08\u0026gt; { | type= \u0026#34;CUST_CAPSLOCK\u0026#34;, | symbols[Group1]= [ k, K, Up], | actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;UP\u0026gt;, clearmods=Lock) ] }; key \u0026lt;AC07\u0026gt; { | type= \u0026#34;CUST_CAPSLOCK\u0026#34;, | symbols[Group1]= [ j, j, Down], | actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;DOWN\u0026gt;, clearmods=Lock) ] }; Ahora, para probar los cambios, podemos cerrar nuestra sesión y volver a entrar, o simplemente abrir una terminal y poner setxkbmap latam.\nSi hicimos algo mal, la terminal dirá algo como que hubo un error al cargar el keymap. Si hicimos algo MUY mal, podría cargarse un fallback, o podríamos tener un teclado chistoso. Como sólo estamos remapeando al nivel de X11, podemos arreglar nuestros errores desde una tty.\nAunque este método puede parecer extremo (creo que es posible hacer archivos con symbols, types y compat por usuario), es realmente muy robusto. Ningún programa que esté a la espera de que presionemos las flechas sabrá que físicamente estamos usando otras teclas. Ni siquiera nuestro gestor de ventanas.\nAdemás, la tecla BloqMayús sigue identificándose como tal cuando no la presiona junto a hjkl. Por lo que ya podemos regresar a nuestros keybinds de awesome y asignar acciones a la tecla con scancode \u0026quot;Caps_Lock\u0026quot; sin problemas.\nAún no he intentado usar uno de los modificadores de XkbOptions como caps:none (en cuyo caso los keybinds de awesome se pueden asignar a \u0026quot;VoydSymbol\u0026quot; si no me equivoco), pero todo apunta a que la tecla como tal ha quedado intacta, salvo que ya no es un toggle switch sino un momentary switch, y si actúa detrás de otras teclas, entonces es un modificador que no cambia de capa, sino que traduce la tecla modificada a los keycodes que querramos.\nDeberíamos poder usar XkbOptions para que caps se identifique como la tecla Escape por ejemplo. Luego, awesome puede usar keybinds como Super+Escape, y vim puede usar BloqMayús para ir al modo normal. De todas formas por ahora me contento con no tener XkbOptions aparte de mousekeys.\nVale la pena hacerlo así? Como todo en Linux, esta es una de muchas formas de lograr lo mismo.\nCada una con sus ventajas y desventajas. Este man logra lo mismo pero usando xbindkeys. Y en muchos lugar se mencionan xbindkeys y xmodmap para cosas similares, principalmente porque son mucho más fáciles de configurar.\nSobre xmodmap, la wiki de arch dice:\n\u0026ldquo;xmodmap is not directly related to X keyboard extension (XKB), as it uses different (pre-XKB) ideas on how keycodes are processed within X. Generally, it is only recommended for the simplest tasks.\u0026rdquo;\nY eso no me agrada. xbindkeys parece bastante mejor, y admite tanto mapeos directos y sencillos (como los del artículo del man) como scripts complejos con guile, un lenguaje basado en lisp.\nDe hecho, usé durante mucho tiempo el script que se muestra aquí y siempre me funcionó perfecto. Se comporta así:\nMi ratón tiene 5 botones.\nSi hago scroll mientras presiono uno de los laterales, el volumen del sistema cambia. Si hago scroll mientras presiono el otro lateral, el volumen del reproductor cambia. Presionar un lateral más la ruedita del ratón, permite mutear el audio del sistema. Presionar el otro lateral más la ruedita del ratón, permite mutear el reproductor. Presionar los laterales solitos los hace funcionar como por defecto (Prev/Next). Así que xbindkeys es muy versátil cuando se lo usa con todo lo que ofrece, pero también es de más alto nivel que lo que hicimos en esta guía, y aunque me funcionó perfectamente para el ratón, no me ha ido tan bien con el teclado.\nEso es contenido para otra guía, pero he visto que un desarrollador de awesome no recomienda usar xbindkeys. Dice así:\n\u0026ldquo;Do not use obsolete tools like xmodmap. I have yet to see setxkbmap also causing this. (And yes, I know that xmodmap is so much easier to use than setxkbmap).\u0026rdquo;\nUna nota muy importante En un inicio de sesión posterior, y todos los que le siguieron, me di cuenta de que las teclas hjkl ya no se auto-repetían cuando las mantenía presionadas, y eso se siente como usar calcetas llenas de lodo.\nAún así, me ayudó a quitarme unas malas costumbre que tenía con vim, pero es un problema enorme de todas formas.\nPara corregirlo, fui a ver aquí, y le agregué líneas autorepeat = yes a cada entrada de symbols/pc, para que todo se vea así:\nkey \u0026lt;AC06\u0026gt; { autorepeat= yes, type= \u0026#34;CUST_CAPSLOCK\u0026#34;, symbols[Group1]= [ h, H, Left], actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;LEFT\u0026gt;, clearmods=Lock) ] }; key \u0026lt;AC07\u0026gt; { autorepeat= yes, type= \u0026#34;CUST_CAPSLOCK\u0026#34;, symbols[Group1]= [ j, j, Down], actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;DOWN\u0026gt;, clearmods=Lock) ] }; key \u0026lt;AC08\u0026gt; { autorepeat= yes, type= \u0026#34;CUST_CAPSLOCK\u0026#34;, symbols[Group1]= [ k, K, Up], actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;UP\u0026gt;, clearmods=Lock) ] }; key \u0026lt;AC09\u0026gt; { autorepeat= yes, type= \u0026#34;CUST_CAPSLOCK\u0026#34;, symbols[Group1]= [ l, L, Right], actions[Group1]= [ NoAction(), NoAction(), RedirectKey(keycode=\u0026lt;RGHT\u0026gt;, clearmods=Lock) ] }; Pero eso no arregló nada y no sé si culpar a X11 o a lo poco que entiendo de cómo se mapea un teclado.\nLo que arregló el problema fue (aún así decidí quedarme con las líneas autorepeat= yes) fue correr xset r \u0026lt;keycode\u0026gt; para cada letra.\nAsí, por ejemplo, viendo que escribí key \u0026lt;AC09\u0026gt; en symbols/pc, si busco eso en keycodes/xfree86, veo que dice \u0026lt;AC09\u0026gt; = 46; y entonces corro xset r 46.\nAl final, lo que hice fue correr lo siguiente al iniciar sesión:\nxset r 43 xset r 46 xset r 45 xset r 44 Eso lo puse en mi .xinitrc cuando no usaba un display manager. Ahora que uso lighdm con minigreeter, lo pongo en .xprofile.\nYa buscaré una forma más limpia e igual de robusta para remapear teclas sin interferir con el autorepeat.\nExtra: typematic delay and typematic rate Si corro xset r rate, el teclado esperará a que mantenga una tecla presionada por 660ms antes de empezar a auto repetirla a 25Hz.\nSi quiero que empiece a repetirla a 30Hz luego de 330ms, corro xset r rate 330 30.\nOtros enlaces de interés https://unix.stackexchange.com/questions/188164/override-a-few-keycodes-with-xkb\nhttps://github.com/jbriales/xkb-extended-keys\n","date":"2023-05-02T00:00:00Z","permalink":"https://fabrice-bernes.github.io/post/caps_hjkl/linux_caps+hjkl_son_flechas/","section":"post","tags":["Linux","X11","xkbmap"],"title":"BloqMayús es una tecla poderosa"},{"categories":["Notas"],"contents":"Nota: Esta guía la escribí hace mucho y puede tener errores o poco detalle en partes importantes.\nAntes que nada Arrancar archiso x86_64. Se inicia sesión como root por defecto (arrancar archiso x86_64 inicia una sesión con los máximos permisos)1\nComprobar que estamos conectados a internet haciendo:\nping archlinux.org Si la computadora recibe datos, entonces sí estamos. Podemos terminar la prueba con Ctrl+c2. Ahora empieza la instalación.\nPara evitar problemas, escogemos la disposición de teclado adecuada, asignando al programa loadkeys el archivo relevante (e.g. loadkeys de-latin1)3. Para ver la lista de disposiciones de teclado hacemos\nls /usr/share/kbd/keymaps/**/*.map.gz Nótese que omitimos la ruta hacia el archivo de-latin1.map.gz y omitimos también su extensión4.\nModos de arranque Debemos revisar si la computadora arranca en modo BIOS, UEFI, o CSM. Esto determinará algunas de las características de la instalación, como las referentes a la llamada partición de arranque, entre otras cosas.\nPara saber en qué modo estamos, corremos ls así:\nls /sys/firmware/efi/efivars Si podemos ver tal directorio sin ningún error, entonces la compu arranca en modo UEFI. Esto implica que Archiso usó systemd-boot (un gestor de arranque) para cargar el kernel y disco RAM inicial (initrd)5.\nSegún el modo (UEFI, BIOS) en que arranque la compu, tendremos que particionar el disco de manera adecuada:\nFormato MBR (Master Boot Record) si la compu inicia en modo BIOS. Formato GPT (Global Partition Table) si la compu inica en modo UEFI. Además, habrá que respetar las limitaciones de dichos formatos, como el tamaño máximo de una partición, etc.\nAquí haremos un disco particionado para funcionar (arrancar, iniciar) en un sistema UEFI.\nSobre la fecha y hora El servicio 6 timedatectl controla la fecha y hora del sistema. Para sincronizarlo con la red, hacemos:\ntimedatectl set-ntp true Luego revisamos que sí esté sincronizado con:\ntimedatectl status Más tarde escogeremos una zona horaria.\nParticionar discos Ya podemos preparar el disco que tendrá ArchLinux. Esto lo haremos con el programa fdisk.\nPrimero vemos los discos que hay conectados: fdisk -l El disco 0 sería sda, el disco 1 sería sdb, etc. Hay sda, sdb, sdc, \u0026hellip; , sdx. Todas las particiones del disco sdx son sdx1, sdx2, \u0026hellip; , sdxn. Cuando decidamos en qué disco queremos trabajar, lo seleccionamos. Aquí como ejemplo trabajaremos con sda, pero este puede no ser el caso. SIEMPRE hay que revisar las cosas 2 veces cuando se trabaja con fdisk.\nSIEMPRE hay que revisar las cosas 2 veces cuando se trabaja con fdisk.\nPara seleccionar sda (como ejemplo):\nfdisk /dev/sda Ahora prepararemos la partición de sistema EFI. Se recomienda hacerla de 512Mb. Es conveniente revisar sus requisitos, riesgos y limitaciones.\nEscribimos n para hacer una nueva partición.\nEscogemos el número que tendrá dicha partición. La convención es seguir un orden ascendente; es decir, si sda ya tenía sda1 y sda2, lo más estándar será nombrar a la siguiente partición con un 3.\nSi presionamos Enter sin haber dado un número, fdisk usará el número indicado como \u0026lt;\u0026lt;default\u0026gt;\u0026gt;.\nEscogemos también el primer sector. Nuevamente, si no se da un arcumento, se usará la propuesta \u0026lt;\u0026lt;default\u0026gt;\u0026gt;.\nLo mismo sucede con el último sector. Pero obviamente, el tamaño de la partición creada será la diferencia del sector final menos el sector inicial.\nPara hacer que el último sector de la partición esté 512Mb después que el primero, escribimos +512M y presionamos Enter\nfdisk suele hacer las particiones del tipo Linux filesystem. Pero queríamos una partición de tipo EFI. Habrá que cambiar el tipo.\nPresionamos t. fdisk pregunta por el número de la partición cuyo tipo queremos cambiar.\nUna vez especificado el número de la partición, presionamos L para tener un listado con los tipos de particiones. La lista es muy larga. Podemos presionar q para salir de ella.\nCuando encontramos el número en la lista para el tipo de formato que buscamos, salimos de la lista y damos dicho número a fdisk.\nAhora comprobamos que la partición sea tal como la queríamos al principio listando las particiones con p\nDe manera similar, creamos una partición grande para el directorio raíz, del tipo Linux Filesystem, y otra partición del tipo Linux swap en el espacio restante (al menos 2Gb).\nRevisamos todo lo que hicimos con p, y SÓLO SI ES CORRECTO, aplicamos los cambios con w. NO HAY VUELTA ATRÁs.\nLuego de correr el comando w(rite) en fdisk, los cambios en el disco son IRREVERSIBLES.\nSe pueden hacer particionados más complejos, pero por ahora esto está bien. Deberíamos tener:\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026ndash;512M\u0026ndash; \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;$\\geq$ 10Gb\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; \u0026mdash;\u0026ndash;$\\geq$ 2Gb\u0026mdash;\u0026ndash; Part. de Win si se hace dual-boot EFI Sistema Linux Swap Ahora nos aseguramos de que la partición de sistema EFI tenga un formato FAT32 así: mkfs.fat -F32 /dev/sdxn Reemplazando sdxn con el disco y partición relevantes (e.g. sdb3)\nLe indicamos a Arch que nuestra partición tipo SWAP será en efecto nuestra área de trasiego con mkswap : mkswap /dev/sdxn y la iniciamos con swapon : swapon /dev/sdxn Nos encargamos también de que la partición del Sistema Linux tenga un formato Ext4 : mkfs.ext4 /dev/sdxn Todo está listo para que arch pase al disco duro. Vamos a montar el sistema de archivos que hemos creado (la partición de Sistema Linux $\\geq$ 10Gb).\nMontar el sistema de archivos Con montar queremos decir:\nhacer una partición accesible a Arch asignándole un archivo (el punto de montaje) en el árbol de directorios.\nPara ello usamos mount :\nmount /dev/sdxn /mnt Donde sdxn es la partición del sistema y se ha montado como /mnt\nCreamos un directorio boot en ese punto de montaje: mkdir mnt/boot Y montaremos la partición de sistema EFI ahí: mount /dev/sdxn /mnt/boot Donde sdxn es la partición de sistema EFI.\nComprobamos que ambas particiones estén montadas en los directorios correctos con df :\ndf En la columna Filesystem buscamos dichas particiones, y en la columna Mounted on estarán los puntos de montaje que hemos asignado:\nFilesystem 1K-blocks Used Available Use% Mounted on dev 8151048 0 8151048 0% /dev run 8159992 1072 8158920 1% /run /dev/sda2 939144724 97067796 794297244 11% / tmpfs 8159992 20124 8139868 1% /dev/shm /dev/sda1 523244 99588 423656 20% /boot tmpfs 8159996 7448 8152548 1% /tmp tmpfs 1631996 16 1631980 1% /run/user/1000 Buscamos tener /mnt para la partición de Sistema Linux, y /mnt/boot para la partición de Sistema EFI.\nAhora que Arch tiene acceso a esas particiones (pues ya tienen un lugar en el árbol de directorios) vamos a instalar los paquetes esenciales con pacstrap.\npacstrap pacstrap es una herramienta para instalar Arch. No debe confundirse con pacman, que se instala con pacstrap y sirve como administrador de paquetes una vez que estamos en Arch (ahora mismo estamos en ArchIso o algo así).\nInstalamos el paquete base, el paquete linux, y el paquete linux-firmware. Todos ellos en /mnt : pacstrap /mnt base linux linux-firmware En realidad son grupos de paquetes, no paquetes individuales.\nAl terminar la instalación, generamos el archivo de configuración del sistema fstab.\nfstab fstab contiene las características de todos los dispositivos de almacenamiento, como sus UUID\u0026rsquo;s, sus opciones de montaje, y sus permisos. Este archivo estará en /etc/fstab, y para generarlo usaremos genfstab :\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab Con esta línea le pedimos a genfstab que revise las particiones puestas en /mnt (esto es, desde ahí hasta el final de la jerarquía en el árbol de directorios), que use los UUID\u0026rsquo;s, y que el resultado (la salida, el output) sea escrito en el archivo /mnt/etc/fstab. Podemos abrir el archivo de salida con vi, sólo para comprobar que se ve correcto:\nvim /mnt/etc/fstab Salimos de vi con q!. Si estamos en modo edición, primero presionamos ESC y luego escribimos :q! para salir sin guardar cambios que hayamos hecho por accidente.\nYa tenemos Arch instalado en el disco, listo para arrancar, pero no configurado.\nSaliendo del medio de instalación, y entrando al sistema operativo Hasta ahora, el prompt de la consola aún dice:\nroot@archiso~ # Donde el signo # indica que la terminal está lista (y esperando) para recibir comandos dados por root, el superusuario o usuario raíz, así que no es necesario correr las cosas con sudo o pedirle privilegios al sistema por otros medios.\nEl # sería reemplazado por un $ si estuviéramos haciendo cosas como un usuario estándar (y tendríamos que usar sudo para cuestiones administrativas, a menos que iniciemos una nueva sesión como usuario-raíz).\nPero lo importante ahora mismo es que el usuario raíz está en el sistema con hostname archiso. Es decir, el USB de instalación, y no la computadora misma7.\nTenemos entonces que cambiar el directorio raíz con arch-chroot. Queremos que nuestro nuevo directorio raíz (el nivel más alto en la jerarquía del árbol de directorios) de todo Arch sea /mnt. Hacemos:\narch-chroot /mnt Ya estamos trabajando en un sistema operativo, pero no tenemos mucho más. /mnt ahora es sólo /. Vamos a configurar algunas de las cosas más esenciales.\nZona horaria Queremos crear un enlace simbólico8 desde /usr/share/zoneinfo/Mexico/General o el archivo adecuado (revisar con ls o con la completición automática con TABULADOR) hacia /etc/localtime. Para ello usamos ln :\nln -sf /usr/share/zoneinfo/Mexico/General /etc/localtime El flag -s y -f se pueden combinar como -sf. La s es de de softlink, y la f de file. No tengo idea de lo que significan esos flags y me da flojera revisar eso.\nAhora sincronizamos el reloj del sistema con el reloj de la mobo9 así:\nhwclock --systohc hc viene de hardware clock.\nTambién queremos activar el locale necesario para tener la localización geográfica y codificación de caracteres adecuados.\nLocalización geográfica La idea de configurar un locale es que todos los programas instalados y sitios web sepan sobre nuestras preferencias de idioma y charset (mapas de caracteres, que incluyen acentos y símbolos. Cirílico para Rusia, kanji para Japón, abjad para Arabia, etc).\nPara activar el locale que queremos usar, necesitamos locale-gen. Pero primero debemos modificar el archivo /etc/locale.gen con un editor de texto.\nAnteriormente usamos vi para revisar el contenido del archivo fstab. Pero vi estaba en el iso del medio de instalación. Ya no lo tenemos ahora que estamos en nuestro propio sistema, con su propia raíz y sus dependencias básicas instaladas.\nEntre esas dependencias está pacman, que podemos usar para instalar vim :\npacman -Sy vim Ahora, con vim instalado, abrimos el archivo de configuración para locale-gen :\nvim /etc/locale.gen Para habilitar un locale, descomentamos el nombre de tal locale. Podemos buscar cadenas de texto haciendo /cadena, reemplazando cadena con lo que buscamos.\nProbemos buscando y descomentando en_US.UTF-8 UTF-8 o es_MX.UTF-8 UTF-8 (o ambos!). Presionamos esc para salir del modo insert, y luego escribirmos :x para guardar y salir.\nAhora corremos locale-gen así:\nlocale-gen Ya que generamos los locales, abrimos /etc/locale.conf con vim:\nvim /etc/locale.conf Y escribimos la siguiente línea:\nLANG=en_US.UTF-8 para que el lenguaje del sistema sea inglés10.\nHostname El Hostname es el nombre que nuestra computadora reporta a la red local. No confundir con su IP. Redes grandes usan nombres con UUID\u0026rsquo;S11, pero podemos usar cualquier nombre (e.g. Poderosísimo_Servidor).\nSi Queremos un UUID, podemos usar uuidgen, o ver qué propone el OS en /etc/machine-id.\nUsuarios y contraseñas Hacemos una contraseña para el usuario root, el cual estamos usando actualmente:\npasswd Y damos la nueva contraseña.\nAhora añadimos un nuevo usuario \u0026ldquo;daquavious\u0026rdquo;:\nuseradd -g users -G power,storage -m daquavious -g es para el grupo, -G es para el(los) subgrupo(s). Todo usuario pertenece a un grupo y cero o más subgrupos.\n-m sirve para crear un directorio hogar. En este caso, se va a crear /home/daquavious.\nSi quisiéramos un nombre de usuario con mayúsculas12:\nuseradd -g users -G power,storage -m Daquavious --force-badname Para darle (o cambiarle) una contraseña a daquavious:\npasswd daquavious Y para cambiar su nombre de daquavious a bingleton:\nusermod -l bingleton daquavious También vamos a hacer un usuario invitado13 :\nuseradd -g user -m invitado Para que invitado no tenga contraseña:\npasswd -d invitado Instalar GRUB y usar os-prober14 Instalamos grub y efibootmgr :\npacman -S grub efibootmgr También os-prober para encontrar y añadir a grub.cfg la partición de inicio de Windows:\npacman -S os-prober Probamos que os-prober funcione corriendo el comando os-prober y esperando que no se muestre ningún error.\nAhora sí, instalamos GRUB (i.e. lo convertimos en nuestro gestor de arranque, el bootloader) especificando la arquitectura de nuestro CPU, el directorio de instalación, y el identificador de GRUB:\ngrub-install --target=x86_64-efi --efi-directory=/boot/ --bootloader-id=GRUB2 La elección del identificador es libre, pero el nombre GRUB2 tiene sentido.\nHay que montar la partición que contiene el bootloader de windows para que os-prober la detecte. Para ello listamos todos los discos y particiones que existen en el sistema:\nfdisk -l y cuando la encontremos (supongamos que es sdxn):\nmount /dev/sdxn /mnt2 Si el punto de montaje (en este caso mnt2) no existe, lo creamos antes de montar con:\nmkdir /mnt2 Creamos automáticamente (se puede hacer manualmente) una configuración para grub:\ngrub-mkconfig -o /boot/grub/grub.cfg Revisamos que se encuentre y cree una entrada de Windows Boot Manager.\nSi ha funcionado, tenemos un dual-boot exitoso, pero la próxima vez que iniciemos Arch (ahora sí, sin el medio de instalación), no podremos descargar paquetes, porque no hemos configurado la red. Es conveniente hacerlo antes de reiniciar el equipo.\nNetworkManager Se puede configurar lo referente al adaptador de internet con mucho detalle, pero de momento, dejamos que networkmanager lo haga. Debemos instalarlo:\npacman -S networkmanager Y debemos hacer que arranque siempre que se inicie arch:\nsystemctl enable NetworkManager Las mayúsculas importan.\nDisposición de teclado También queremos que Arch siempre cargue la disposición de teclado que escogimos esta sesión cuando usamos loadkeys al inicio de la guía. Para ello, abrimos /etc/vconsole.conf con un editor de texto (como siempre, vim está bien), y escribimos:\nKEYMAP=la-latin1 para un teclado latinoamericano15.\nCon todo lo anterior ya podemos salir de arch con exit para regresar al medio de instalación, y apagar el equipo con shutdown now o reiniciar con reboot. Luego quitamos el USB con la ISO de Arch y comprobamos que la mobo arranque GRUB, y que GRUB nos muestre entradas para Linux y para Windows como se debe.\nPor último, dejo aquí un pdf. Si no lo puedes leer desde aquí,\nDescárgalo haciéndo click aquí ¿No es un riesgo permitir que alguien con un USB pueda arrancar un OS con máximos permisos?\nSí. Pero si esa persona tuvo permiso para poner un usb en un puerto y además arrancar la computadora desde cero, entonces ya es alguien con acceso físico, que es en sí un permiso. Además, las motherboards pueden denegar arranque a OS\u0026rsquo;es que no sepan responder a una clave en la memoria de arranque seguro (secure boot). De hecho para instalar arch, tuve que borrar las claves de arranque seguro porque mi motherboard sólo aceptaba ISO\u0026rsquo;s firmadas por Microsoft\n\u0026#160;\u0026#x21a9;\u0026#xfe0e; Ctrl+C envía una señal al proceso que estaba escuchando al teclado. Esta señal es SIGINT. Para más sobre señales, ver TODO:señales.md\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLa distribución de mi teclado funcionó bien con es.map, y aún mejor con latin.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDe manera similar, la fuente de la consola se cambia con el programa setfont, los archivos de fuentes están en /usr/share/kbd/consolefonts\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSi no existe ese directorio, la compu arranca en modo BIOS o en modo CSM, y ArchLinux usó syslinux en vez de systemd-boot. Esta guía la escribí para motherboard con interfaz UEFI\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUn servicio es un proceso que no espera interacciones con el usuario más allá de iniciarlo o detenerlo manualmente; por lo demás, este proceso está bajo su propia dirección o, más comúnmente, bajo la dirección del llamado init system. En nuestro caso, el init system es systemd. Ver la nota TODO:Systemd\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLa sintaxis del prompt por defecto es username@hostname workingdir #/$. Si vemos root@archiso~ #, sabemos que el usuario llamado root está en la computadora llamada archiso y en el directorio ~\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nLos enlaces simbólicos son algo similar a lo que en MSWindows se conoce como \u0026ldquo;acceso directo\u0026rdquo;. Hay mucho que decir al respecto, y tal vez valga la pena escribir una nota (TODO)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMotherboard, Tarjeta madre\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nO es_MX.UTF-8 para usar español, obviamente. Prefiero inglés porque es el lenguaje en el que se suelen hacer preguntas, enviar logs, etc\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUniversally Unique Identifier\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nEs mala idea hacer nombres con mayúsculas. Usuarios con mayúsculas (e.g. Invitado) sólo crean confusión, pues muchos servicios web no distinguen mayúsculas (e.g. servidores de correo electrónico), y además existen sistemas que conservan ajustes antiguos de la época en que existían teclados/sistemas con sólo mayúsculas. Algunos programas leen una mayúscula y asumen que se está trabajando en un teclado de ese tipo.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nHacer que un invitado sea parte de power y storage es una idea estúpida. Le estamos dando el poder de apagar nuestro sistema o crear/borrar archivos que no debería\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nInstrucciones válidas sólo para sistemas UEFI\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nEsta es la distribución de teclado que se usará en las TTY\u0026rsquo;s, y es independiente de la que se use en un entorno gráfico (e.g. X11)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-03-31T00:00:00Z","permalink":"https://fabrice-bernes.github.io/post/instalar_arch/","section":"post","tags":["Linux"],"title":"Instalar Arch"},{"categories":["Basura"],"contents":"Matemáticas $$\\frac{1}{4\\pi\\epsilon_{0}}$$\nImágenes Y más texto aquí\n","date":"2023-03-31T00:00:00Z","permalink":"https://fabrice-bernes.github.io/post/prueba/prueba/","section":"post","tags":["Linux"],"title":"Prueba"},{"categories":null,"contents":"Sobre el sitio GitHub te deja tener un sitio personal, así que lo voy a usar como vertedero para notas mal hechas de las cosas que siempre olvido en cuanto termino de usarlas.\nTambién subiré notas de los mejores cursos que llevé en la universidad, pero a esas no tiene sentido darles un formato \u0026ldquo;de blog\u0026rdquo;, así que tendrán sus propias entradas con pdf\u0026rsquo;s para descargar.\nMe interesa saber si encontraste este sitio, y cómo lo encontraste. Si puedes escribirme un correo o poner un comentario (Cuando aprenda a usar staticman o algo así), estaría muy bien.\n","date":"0001-01-01T00:00:00Z","permalink":"https://fabrice-bernes.github.io/about/","section":"","tags":null,"title":""}]